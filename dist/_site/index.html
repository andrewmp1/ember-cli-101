<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Learn Ember-CLI with the Ember-CLI 101 Workshop from the San Diego Ember meetup group">
    <meta name="author" content="San Diego Ember">
    <title>Ember-CLI 101 Workshop by San Diego Ember</title>
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet">
    <link href="/site.css" rel="stylesheet">
  </head>

  <body>
    <div class="container">

      <header class="page-header">
        <h1>Ember-CLI 101 Workshop</h1>
      </header>

      <p>Welcome to Ember-CLI 101 workshop hosted by <a href="http://www.meetup.com/sandiego-ember/">San Diego Ember</a> with help from our friends at <a href="http://www.meetup.com/ember-sc">Ember-SC</a>.</p>

<p>This workshop is loosely guided by <a href="http://blog.abuiles.com/">Adolfo Builes&#39;</a> book Ember-CLI 101.  You can <a href="https://leanpub.com/ember-cli-101/c/san-diego-101">get $10 off for San Diego Ember group</a>.</p>

<h2>Pre-event setup instructions</h2>

<ol>
<li><a href="http://git-scm.com/downloads">Install Git</a></li>
<li><a href="https://nodejs.org/download/">Install Node.js</a></li>
<li>Setup NPM for non-sudo installation

<ol>
<li>NPM is the node package manager.  It will automatically be installed when you install node.</li>
<li>NPM installs packages <em>locally</em> (within the directory it is invoked in) for per-project modules, or <em>globally</em> for packages you want accessible everywhere.</li>
<li>However, by default NPM installs global packages in a root-restricted location, requiring SUDO to install.  This creates a <strong>huge</strong> headache.  As an alternative, <em>before</em> you install any packages, follow <a href="https://github.com/sindresorhus/guides/blob/master/npm-global-without-sudo.md">this guide</a> to configure your NPM to install in your home directory without requiring sudo.</li>
</ol></li>
<li>Install Bower: <code>npm i -g bower</code></li>
<li>Install Ember-CLI: <code>npm i -g ember-cli</code></li>
<li>And create a new project named &#39;workshop&#39;: <code>ember new workshop</code></li>
</ol>

<h2>Goal: reduce the glue</h2>

<p>Web application development can involve a lot of repetition.  Attempts to reduce the repetition involved in web development has given rise to a variety of scaffolding tools and best practices.  These scaffolding tools are all trying to do the same thing:  reduce the amount of work necessary to &quot;get started&quot; by providing a set of &quot;best practices&quot; that are enabled default.  These choices include things like:</p>

<ol>
<li>Application directory structure</li>
<li>Generators for common components</li>
<li>Modularity choices (AMD/node modules/etc) <strong>TODO:  How to explain this better?</strong></li>
<li>Build system</li>
<li>Asset compilation &amp; minification</li>
<li>Testing framework and setup</li>
</ol>

<h2>Ember-CLI</h2>

<p>Ember-CLI provides choices for all of the aforementioned areas.  We&#39;ll dive into some of these choices in more detail later but at a high level Ember-CLI builds in:</p>

<ol>
<li>A directory structure which we&#39;ll explore more later</li>
<li>Generators for all common components</li>
<li>ES6 modules transpiled to AMD</li>
<li>Broccoli build tool for builds. (Lightning fast and extensible with plugin architecture</li>
<li>Asset minification also via Broccoli.</li>
<li>QUnit for testing</li>
</ol>

<h3>Modules</h3>

<p>Modules allow you to divide logical portions of code into smaller, functional pieces and include them as needed. As your application grows, smaller pieces of functional code become easier to manage, support, maintain and test.</p>

<p><strong>TODO: more stuff</strong></p>

<h2>Best practices</h2>

<ol>
<li>Code

<ol>
<li><code>camelCase</code> naming</li>
<li>use modules, avoid globals</li>
<li>reusable code → mixins, extend, add-ons</li>
</ol></li>
<li>Files

<ol>
<li><code>kebab-case-naming.js</code></li>
<li>children in subdirectory → <code>routes/invoices/edit.js</code> &amp; <code>routes/invoices/new.js</code></li>
</ol></li>
</ol>

<h2>Project Organization: High level</h2>

<p>Now that you have an Ember-CLI generated project, let&#39;s step inside and start exploring:</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">cd </span>workshop
<span class="gp">$</span> ls -A
<span class="go">app               .bowerrc     dist           .git        node_modules  README.md    tmp</span>
<span class="go">bower_components  Brocfile.js  .editorconfig  .gitignore  package.json  testem.json  .travis.yml</span>
<span class="go">bower.json        config       .ember-cli     .jshintrc   public        tests        vendor</span>
</code></pre></div>
<h4>package.json and node_modules</h4>

<p>The first things to notice is the file <code>package.json</code> and the directory <code>node_modules</code>. These are from NPM, and if you&#39;re new to NPM, take a look at what is in the <code>package.json</code> file.  This file contains information about what NPM modules are required to run and develop our app. You&#39;ll see that the packages needed for broccoli and Ember-CLI are specified here. When using Ember-CLI you won&#39;t often edit this directly. If you were to install any Ember-CLI addons yourself, you would see them show up in here as well. The packages specified in <code>package.json</code> will be installed in the <code>node_modules</code> directory.</p>

<h4>bower.json and bower_components</h4>

<p>The next thing to look at is the file <code>bower.json</code> and the <code>bower_components</code> directory. These are similar to <code>package.json</code> and <code>node_modules</code>. Bower has become the de facto standard for front-end package management and our Ember-CLI application will use it to manage many of our dependencies. If you open up <code>bower.json</code> you&#39;ll see that our application comes out of the box with not only Ember but jQuery, Ember Data (for data persistence), and QUnit (for testing).</p>

<h4>tests</h4>

<p>Ember-CLI comes out-of-the box with a testing framework and provides some helpers to make testing easier. You can test models, routes, controllers and components. Possibly the most useful types of tests you can write, however, are unit and acceptance tests.</p>

<p>Unit tests allow us to focus on specific functionality and do not require the entire Ember application be running. Acceptance tests, also called integration tests, are used to test the flow of your app. They emulate user interactions throughout your application and using helpers you can make assertions about the expected functionality.</p>

<h3>public and vendor</h3>

<p>You may be wondering where images, fonts and other miscellaneous asset files should go. The answer is the <code>public</code> directory. These will be served at the root of your application.</p>

<p>Similarly, you may have JavaScript or CSS dependencies that are not in bower. These can be stored in the <code>vendor</code> directory. Loading vendor files is not something we will cover in this workshop.</p>

<h4>The &#39;app&#39; directory</h4>

<p>The app directory is where we&#39;re going to put all of our own code.  It is carefully structured with an appropriate place for each type of module:</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ls app
<span class="go">app.js          controllers     index.html      router.js       styles          views</span>
<span class="go">components      helpers         models          routes          templates</span>
</code></pre></div>
<p>Some of these may sound familiar to you, while others may be brand new.  Don&#39;t worry yet if you don&#39;t know what all of these different pieces are.  We&#39;ll get to them one by one.</p>

<h2>Ready to code!</h2>

<ol>
<li><code>ember serve</code></li>
<li>http://localhost:4200</li>
</ol>

<h2>Install Bootstrap</h2>

<p>Let&#39;s use Bootstrap to make our website look nice.  This step isn&#39;t strictly necessary but it&#39;ll make our application snazzier.</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ember install:bower bootstrap
</code></pre></div>
<p>Now we need to include the Bootstrap CSS into our build process.  Let&#39;s add the following to our <code>Brocfile.js</code> below <code>var app = new EmberApp();</code> and above <code>module.exports = app.toTree();</code>:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="kr">import</span><span class="p">(</span><span class="s1">&#39;bower_components/bootstrap/dist/css/bootstrap.css&#39;</span><span class="p">);</span>
</code></pre></div>
<p>Our <code>Brocfile.js</code> should look something like this now:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="cm">/* global require, module */</span>

<span class="kd">var</span> <span class="nx">EmberApp</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;ember-cli/lib/broccoli/ember-app&#39;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EmberApp</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="kr">import</span><span class="p">(</span><span class="s1">&#39;bower_components/bootstrap/dist/css/bootstrap.css&#39;</span><span class="p">);</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">app</span><span class="p">.</span><span class="nx">toTree</span><span class="p">();</span>
</code></pre></div>
<p>If you already have <code>http://localhost:4200/</code> opened in your browser, you&#39;ll see it auto-refresh to reveal our new page.  If not, go visit <code>http://localhost:4200/</code> now.</p>

<p>The font of our header should have changed.</p>

<p><strong>ProTip™</strong> Ember-CLI uses live-reloading to persist changes to the browser without the need of reloading. Neat!</p>

<p>Now let&#39;s add a big header introducing our blog.  Let&#39;s update our <code>application.hbs</code> file to add a jumbotron header and wrap our page content in a Bootstrap <code>container</code>:</p>
<div class="highlight"><pre><code class="language-handlebars" data-lang="handlebars"><span class="x">&lt;div class=&quot;jumbotron&quot;&gt;</span>
<span class="x">  &lt;div class=&quot;container&quot;&gt;</span>
<span class="x">    &lt;h1&gt;Bernice&#39;s Blog&lt;/h1&gt;</span>
<span class="x">  &lt;/div&gt;</span>
<span class="x">&lt;/div&gt;</span>

<span class="x">&lt;div class=&quot;container&quot;&gt;</span>
<span class="x">  </span><span class="cp">{{</span><span class="nv">outlet</span><span class="cp">}}</span><span class="x"></span>
<span class="x">&lt;/div&gt;</span>
</code></pre></div>
<p>Our site should have refreshed in our web browser now, revealing a big header for our blog.</p>

<h2>Diversion: Accessing our API with ember-data</h2>

<p>Ember is a client side framework and so when we have data that we want to persist, we need a back-end API.  We want an API to serve up our blog posts and allow users to view and submit comments.</p>

<p>We could use fixtures or a mock API, but some friendly back-end developers have already made a working API for us so let&#39;s use that.</p>

<p>Our API is setup at https://sandiego-ember-cli-101.herokuapp.com supporting the following endpoints</p>

<table>
    <thead>
        <tr>
            <th>Verb</th><th>path</th><th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>GET</td><td>/blog-posts</td><td>List of blog posts</td>
        </tr>
        <tr>
            <td>GET</td><td>/blog-posts/:id</td><td>Retrieve a post</td>
        </tr>
        <tr>
            <td>PUT</td><td>/blog-posts/:id</td><td>Update a post</td>
        </tr>
        <tr>
            <td>DELETE</td><td>/blog-posts/:id</td><td>Delete a post</td>
        </tr>
        <tr>
            <td>GET</td><td>/comments</td><td>List of blog comments</td>
        </tr>
        <tr>
            <td>GET</td><td>/comments/:id</td><td>Retrieve a comment</td>
        </tr>
        <tr>
            <td>PUT</td><td>/comments/:id</td><td>Update a comment</td>
        </tr>
        <tr>
            <td>DELETE</td><td>/comments/:id</td><td>Delete a comment</td>
        </tr>
    </tbody>
</table>

<p>Our API uses <code>snake_case</code> in the JSON it sends, the convention for Ruby on Rails APIs. Ember expects everything to be <code>camelCase</code>, so how can we connect these two nicely? Fortunately, we can use an Ember Data adapter to consumer our API and adapt it to the style we use in Ember.</p>

<p>We can set up an adapter at the level of an individual model, but since we&#39;ll be using the same API for all our models, let&#39;s set one up for the entire application:</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ember g adapter application
<span class="go">version: 0.2.2</span>
<span class="go">  installing</span>
<span class="go">    create app/adapters/application.js</span>
<span class="go">  installing</span>
<span class="go">    create tests/unit/adapters/application-test.js</span>
</code></pre></div>
<p>Let&#39;s open up that adapter and see what is there:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">DS</span> <span class="nx">from</span> <span class="s1">&#39;ember-data&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">RESTAdapter</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
<span class="p">});</span>
</code></pre></div>
<p>We&#39;re using an Ember Data built-in adapter called the RESTAdapter. Building a custom adapter isn&#39;t too hard, but we don&#39;t need to because Ember Data already has an adapter custom built for Rails APIs.</p>

<p>Let&#39;s update our file to use the Ember adapter for Rails APIs:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">DS</span> <span class="nx">from</span> <span class="s1">&#39;ember-data&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">ActiveModelAdapter</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
<span class="p">});</span>
</code></pre></div>
<p>Finally, to point our Ember app at the API we&#39;ve set up, let&#39;s restart &#39;ember serve&#39; using the proxy option to point Ember to the API we want to access:</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ember serve --proxy https://sandiego-ember-cli-101.herokuapp.com
<span class="go">version: 0.2.2</span>
<span class="go">Proxying to https://sandiego-ember-cli-101.herokuapp.com</span>
<span class="go">Livereload server on port 35729</span>
<span class="go">Serving on http://localhost:4200/</span>
</code></pre></div>
<h2>Blog post model</h2>

<h3>Make a blog post model</h3>

<p>For our test application, we&#39;re going to create a blog.  Let&#39;s start off by using a generator to create a model for the blogPost.  We&#39;ll give it a couple of basic fields and take a look at what happens.</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ember generate model blogPost title:string body:string
<span class="go">installing</span>
<span class="go">    create app/models/blog-post.js</span>
<span class="go">installing</span>
<span class="go">    create tests/unit/models/blog-post-test.js</span>
</code></pre></div>
<p>OK, Ember-CLI has just created for us both a model file in <code>app/models</code> and a test file in <code>tests/unit/models</code>.  Let&#39;s take a look at the model and see what it contains:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">DS</span> <span class="nx">from</span> <span class="s1">&#39;ember-data&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">title</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">),</span>
  <span class="nx">body</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
 <span class="p">});</span>
</code></pre></div>
<p>What is that funky syntax?  <code>import DS from &#39;ember-data&#39;</code> and <code>export default DSModel.extend()</code>?  Welcome to the world of tomorrow!</p>

<p>Those <code>import</code> and <code>export</code> statements use ECMAScript 6 module syntax. Thanks to the magic of transpilers, we can already use them today even though no browsers support ES6 yet.  This should look familiar if you have used Node.js or AMD modules, there&#39;s just slightly different syntax.  We&#39;re importing a module from &#39;ember-data&#39; and calling it <code>DS</code>.  Then we&#39;re extending the <code>DS.Model</code> class and using that as our module export.</p>

<p>Our model specifies every field it should have, in this case <code>title</code> and <code>body</code>.  If we later decide we want another field (perhaps a published date) we just need to add it to our model:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">DS</span> <span class="nx">from</span> <span class="s1">&#39;ember-data&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">title</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">),</span>
  <span class="nx">body</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">),</span>
  <span class="nx">publishedDate</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">)</span>
<span class="p">});</span>
</code></pre></div>
<h3>Test our blog post model</h3>

<p>Testing can seem daunting if you put it off for too long so lets get right to it and write a test for that model we just created. Ember-CLI has us covered. When we generated our blog post model Ember-CLI also generated a test module for our model:</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ls tests/unit/models
<span class="go">blog-post-test.js</span>
</code></pre></div>
<p>Pretty cool, huh? Let&#39;s open up <code>tests/unit/models/blog-post-test.js</code> and see what Ember-CLI generated for us:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span>
  <span class="nx">moduleForModel</span><span class="p">,</span>
  <span class="nx">test</span>
<span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;ember-qunit&#39;</span><span class="p">;</span>

<span class="nx">moduleForModel</span><span class="p">(</span><span class="s1">&#39;blog-post&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">// Specify the other units that are required for this test.</span>

<span class="p">});</span>

<span class="nx">test</span><span class="p">(</span><span class="s1">&#39;it exists&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">assert</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">model</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">subject</span><span class="p">();</span>
  <span class="c1">// var store = this.store();</span>
  <span class="nx">assert</span><span class="p">.</span><span class="nx">ok</span><span class="p">(</span><span class="o">!!</span><span class="nx">model</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>That looks like a lot! First is the <code>import</code> statement. This imports the <code>ember-qunit</code> package we need for writing our test.</p>

<p>The first section you see, <code>moduleForModel</code>, is where any necessary loading for the model testing will be done. Each test is self-contained, so any dependencies (for example if one model depends on another) must be defined here. We don&#39;t need to worry about this for our simple blog post model.</p>

<p>The next section, <code>test</code>, shows how we define an individual test. One test can have many assertions but should test only one thing. The generator created a default test which asserts that our model exists.</p>

<p>Since we have about as much as we can test in here already for our small model, let&#39;s make sure the tests pass by running <code>ember test</code>.</p>

<p><strong>ProTip™</strong> If you ever need to know what generators are available, just type <code>ember help generate</code> and enjoy a deliciously long list of generating goodness.</p>

<h2>Adding blog posts to our homepage</h2>

<h3>Create the route</h3>

<p>If we want to see blog posts on our website, we need to render them into our HTML.  Ember&#39;s view layer places routes and their associated URLs front and center.  The way to show something is to create a route and associated template.</p>

<p>Let&#39;s start once again from a generator, this time for our index page route:</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ember generate route index
<span class="go">installing</span>
<span class="go">  create app/routes/index.js</span>
<span class="go">  create app/templates/index.hbs</span>
<span class="go">installing</span>
<span class="go">  create tests/unit/routes/index-test.js</span>
</code></pre></div>
<p>This creates a few files for our index route and template file.</p>

<p>Looking at <code>app/routes/index.js</code> we see:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">Ember</span> <span class="nx">from</span> <span class="s1">&#39;ember&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Ember</span><span class="p">.</span><span class="nx">Route</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
<span class="p">});</span>
</code></pre></div>
<h3>Update the template</h3>

<p>Let&#39;s take a look at the template file that was generated for us in <code>app/templates/index.hbs</code>:</p>
<div class="highlight"><pre><code class="language-handlebars" data-lang="handlebars">
</code></pre></div>
<p>Just this funky thing called <code>.  Ember.js uses handlebars for templating, and the `outlet` variable is a special variable that Ember uses to say &quot;insert any subtemplates here&quot;.  If you&#39;ve done anything with ruby on rails, think `yield` and you&#39;ll be awfully close.  Our `index` template is the end of the line for our homepage so let&#39;s remove the</code> and add a sample post:</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;article&gt;</span>
  <span class="nt">&lt;header</span> <span class="na">class=</span><span class="s">&quot;page-header&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h2&gt;</span>My Blog Post<span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;/header&gt;</span>
  <span class="nt">&lt;p&gt;</span>This is a test post.<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/article&gt;</span>
</code></pre></div>
<p>Go look at the website in your browser again. Our &#39;My Blog Post&#39; header should appear nicely beneath our big site header.</p>

<h3>Putting our posts on the page</h3>

<p>So far we have only put some HTML on our page. Let&#39;s use the API to show our actual blog posts.</p>

<p>First let&#39;s add a <code>model</code> to our route. One of the jobs of routes is to provide a model to their template. Our model should be a list of blog posts retrieved from our API.</p>

<p>We could manually provide list of blog posts as our model:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">Ember</span> <span class="nx">from</span> <span class="s1">&#39;ember&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Ember</span><span class="p">.</span><span class="nx">Route</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">model</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[{</span>
      <span class="nx">title</span><span class="o">:</span> <span class="s2">&quot;First post&quot;</span><span class="p">,</span>
      <span class="nx">body</span><span class="o">:</span> <span class="s2">&quot;This is the post body.&quot;</span>
    <span class="p">}];</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Instead let&#39;s use the data store to retrieve all of our blog posts:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">Ember</span> <span class="nx">from</span> <span class="s1">&#39;ember&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Ember</span><span class="p">.</span><span class="nx">Route</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">model</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s1">&#39;blog-post&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Now we should update our index template to loop over each of our blog posts and render it:</p>
<div class="highlight"><pre><code class="language-handlebars" data-lang="handlebars"><span class="x">  &lt;article&gt;</span>
<span class="x">    &lt;header class=&quot;page-header&quot;&gt;</span>
<span class="x">      &lt;h2&gt;&lt;/h2&gt;</span>
<span class="x">    &lt;/header&gt;</span>
<span class="x">    &lt;p&gt;&lt;/p&gt;</span>
<span class="x">  &lt;/article&gt;</span>
</code></pre></div>
<p>The handlebars each helper allows us to enumerate over a list of items.  This should print out all of our blog posts to the page.  Let&#39;s check out our homepage in our browser again and make sure it worked.</p>

<p><img src="https://s3.amazonaws.com/f.cl.ly/items/0e0w0u2b2o3d0r47301y/Screen%20Shot%202015-03-31%20at%201.45.32%20PM.png" alt="display all blog posts"></p>

<h2>Additional Blog post route(s)</h2>

<p>What if we want to share a link to one of our blog posts?  To do that, we would need a page for each blog post.  Let&#39;s make those!</p>

<h3>Create the route</h3>

<p>Let&#39;s start by using a generator to make the new files we&#39;ll need:</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ember generate route blogPost --type<span class="o">=</span>resource --path<span class="o">=</span>/post/:blog_post_id
<span class="go">version: 0.2.2</span>
<span class="go">installing</span>
<span class="go">  create app/routes/blog-post.js</span>
<span class="go">    create app/templates/blog-post.hbs</span>
<span class="go">    installing</span>
<span class="go">      create tests/unit/routes/blog-post-test.js</span>
</code></pre></div>
<p>This creates a few files, and also adds some stuff to your  <code>app/router.js</code>:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">Ember</span> <span class="nx">from</span> <span class="s1">&#39;ember&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">config</span> <span class="nx">from</span> <span class="s1">&#39;./config/environment&#39;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">Router</span> <span class="o">=</span> <span class="nx">Ember</span><span class="p">.</span><span class="nx">Router</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">location</span><span class="o">:</span> <span class="nx">config</span><span class="p">.</span><span class="nx">locationType</span>
<span class="p">});</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Router</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">resource</span><span class="p">(</span><span class="s1">&#39;blogPost&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/post/:blog_post_id&#39;</span>
  <span class="p">},</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{});</span>
<span class="p">});</span>
</code></pre></div>
<p>Here it has defined a resource for us with a dynamic segment in the route, <code>:blog_post_id</code>. This dynamic segment will be extracted from the URL and passed into the <code>model</code> hook on the <code>post</code> route. We can then use this parameter to look up that exact <code>blog-post</code> in the store. So let&#39;s open up <code>routes/blog-post.js</code> that was generated for us and do just that.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">Ember</span> <span class="nx">from</span> <span class="s1">&#39;ember&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Ember</span><span class="p">.</span><span class="nx">Route</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">model</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s1">&#39;blog-post&#39;</span><span class="p">,</span> <span class="nx">params</span><span class="p">.</span><span class="nx">blog_post_id</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<h3>Update the template</h3>

<p>In order to make sure this is working, let&#39;s add some markup to <code>app/blog-post.hbs</code> that will display a post:</p>
<div class="highlight"><pre><code class="language-handlebars" data-lang="handlebars"><span class="x">&lt;article&gt;</span>
<span class="x">  &lt;header class=&quot;page-header&quot;&gt;</span>
<span class="x">    &lt;h1&gt;&lt;/h1&gt;</span>
<span class="x">  &lt;/header&gt;</span>
<span class="x">  &lt;p&gt;&lt;/p&gt;</span>
<span class="x">&lt;/article&gt;</span>
</code></pre></div>
<p>Since we happen to know there is a blog post with <code>id: 1</code> on our API server, we can manually visit <code>http://localhost:4200/post/1</code> in our browser to test with an example blog post.</p>

<h3>The magic of Ember-Data</h3>

<p>Ember-Data&#39;s REST Adapter comes with some freebies to save us time and unnecessary code. The adapter that we are using, <code>ActiveModelAdapter</code> is an extension of the REST Adapter, so we get to take advantage of this automagic if our application follows the URL conventions expected of the REST Adapter.</p>

<p>Based on our route&#39;s dynamic URL segments the REST Adapter will make the proper calls to the application&#39;s API for the model hook.</p>

<table>
  <thead>
    <tr>
      <td>Action</td>
      <td>HTTP Verb</td>
      <td>URL</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Find</td>
      <td>GET</td>
      <td>/post/:blog_post_id</td>
    </tr>
    <tr>
      <td>Find All</td>
      <td>GET</td>
      <td>/post</td>
    </tr>
    <tr>
      <td>Update</td>
      <td>PUT</td>
      <td>/post/:blog_post_id</td>
    </tr>
    <tr>
      <td>Create</td>
      <td>POST</td>
      <td>/post</td>
    </tr>
    <tr>
      <td>Delete</td>
      <td>DELETE</td>
      <td>/post/:blog_post_id</td>
    </tr>
  </tbody>
</table>

<p>The store action determines the model name based on the defined dynamic segment. In our example <code>:blog_post_id</code> contains the proper snake-case name for our model with the suffix <code>_id</code> appended.</p>

<p>To confirm that this works, <strong>delete the <code>routes/blog-post.js</code> file</strong> and verify that our blog post page (http://localhost:4200/post/1) still works properly after reload.</p>

<h3>Handlebars link-to helper</h3>

<p>Now that we have unique URLs for each blog post, we can link to these URLs from our index route.</p>

<p>To add these links open up the <code>app/templates/index.hbs</code> file and add a `` helper around our blog title:</p>
<div class="highlight"><pre><code class="language-handlebars" data-lang="handlebars"><span class="x">  &lt;article&gt;</span>
<span class="x">    &lt;h2&gt;&lt;/h2&gt;</span>

<span class="x">  &lt;/article&gt;</span>
</code></pre></div>
<p>Now take a look at <code>http://localhost:4200</code> and a link should appear. <strong>Click it!</strong> And now you&#39;re at the page for our blog post.</p>

<h3>Acceptance testing</h3>

<p>With some user interaction added to our application we can now create an acceptance test. The user flow for this test will be:</p>

<ol>
<li>Visit <code>/</code></li>
<li>Click the first blog link</li>
<li>Verify that the URL now matches <code>/post/:blog_post_id</code></li>
</ol>

<p>First we will have to generate our acceptance test.</p>
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ember generate acceptance-test blog-post-show
<span class="go">installing</span>
<span class="go">  create tests/acceptance/blog-post-show-test.js</span>
</code></pre></div>
<p>Open the created file <code>tests/acceptance/blog-post-show-test.js</code> and see what is there:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">Ember</span> <span class="nx">from</span> <span class="s1">&#39;ember&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span>
  <span class="nx">module</span><span class="p">,</span>
  <span class="nx">test</span>
<span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;qunit&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">startApp</span> <span class="nx">from</span> <span class="s1">&#39;workshop/tests/helpers/start-app&#39;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">application</span><span class="p">;</span>

<span class="nx">module</span><span class="p">(</span><span class="s1">&#39;Acceptance: BlogPostShow&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">beforeEach</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">application</span> <span class="o">=</span> <span class="nx">startApp</span><span class="p">();</span>
  <span class="p">},</span>

  <span class="nx">afterEach</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">Ember</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">application</span><span class="p">,</span> <span class="s1">&#39;destroy&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">test</span><span class="p">(</span><span class="s1">&#39;visiting /blog-post-show&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">assert</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">visit</span><span class="p">(</span><span class="s1">&#39;/blog-post-show&#39;</span><span class="p">);</span>

  <span class="nx">andThen</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">currentPath</span><span class="p">(),</span> <span class="s1">&#39;blog-post-show&#39;</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<p>Let&#39;s first rename this test to something more applicable and remove the stuff inside.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;visit blog post from index&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">assert</span><span class="p">)</span> <span class="p">{</span>

<span class="p">});</span>
</code></pre></div>
<p>There are a few helpers here that we will use <strong>a lot</strong> when writing acceptance tests.</p>

<ul>
<li><code>visit(route)</code>: Visits the given route</li>
<li><code>click(selector or element)</code>: Clicks the element and triggers any actions triggered by that element&#39;s click event</li>
<li><code>andThen(callback)</code>: Waits for any preceding promises to continue</li>
</ul>

<p>Since <code>visit</code> and <code>click</code> are both asynchronous helpers we need to wrap subsequent logic in <code>andThen</code> to make sure actions complete before continuing onto the next step.</p>

<p>Now we will code out the steps listed above to test that we can link to a blog post from index.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;visit blog post from index&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">assert</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">visit</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">blogSelector</span> <span class="o">=</span> <span class="s1">&#39;article:first-of-type a&#39;</span><span class="p">;</span>

  <span class="nx">andThen</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">click</span><span class="p">(</span><span class="nx">blogSelector</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="nx">andThen</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">currentURL</span><span class="p">(),</span> <span class="s1">&#39;/post/1&#39;</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<p>Verify the tests are passing by visiting <code>http://localhost:4200/tests</code> in the browser.</p>

<h2>Blog comment</h2>

<p><strong>TODO</strong> Make blog comment model and relate to post
<strong>TODO</strong> Make comments show up on blog post detail page</p>

<h2>Submitting a comment</h2>

<p><strong>TODO</strong> Add form to submit a comment</p>

<h2>More?</h2>

<p><strong>TODO</strong></p>

<ol>
<li>Paginate homepage?</li>
<li>Make archive page for previous blog posts?</li>
<li>Use gravatar for comments</li>
</ol>


      <footer class="footer">
        <p>&copy; San Diego Ember and friends 2015</p>
      </footer>

    </div>
  </body>
</html>
